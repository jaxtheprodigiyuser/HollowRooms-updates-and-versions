<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hollow Rooms</title>
<style>
  :root {
    --bg: #0b0c10;
    --ui: #c2c7d0;
    --red: #9c2e2e;
    --panel: #14161b;
  }
  html, body {
    margin: 0;
    height: 100%;
    background: var(--bg);
    color: var(--ui);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif;
    user-select: none;
    overflow: hidden;
  }
  #wrap {
    position: relative;
    width: 100vw;
    height: 100vh;
    background: radial-gradient(circle at 50% 50%, #0c0e12 0%, #0b0c10 60%, #08090d 100%);
  }
  canvas { position: absolute; inset: 0; }
  #hud {
    position: absolute;
    left: 1rem;
    bottom: 1rem;
    font-size: 14px;
    letter-spacing: 0.5px;
    text-shadow: 0 1px 2px rgba(0,0,0,0.6);
    z-index: 6;
  }
  #hud .bar {
    width: 240px;
    height: 8px;
    background: #1a1d22;
    border-radius: 4px;
    overflow: hidden;
    margin: 6px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.35) inset;
  }
  #hud .fill { height: 100%; background: linear-gradient(90deg, #4663ff 0%, #2f48c4 100%); transition: width 140ms linear; }
  #hud .fill.stam { background: linear-gradient(90deg, #59db78 0%, #2ea34d 100%); }
  #hud .fill.sanity { background: linear-gradient(90deg, #e49f3e 0%, #c7791a 100%); }
  #titleOverlay {
    position: absolute; inset: 0; display: grid; place-items: center;
    background: rgba(8,9,13,0.95); z-index: 10; transition: opacity 800ms ease;
  }
  #titleOverlay.hidden { opacity: 0; pointer-events: none; }
  .panel {
    max-width: 760px; padding: 1.5rem 2rem; border: 1px solid #1c1f25; border-radius: 10px;
    background: linear-gradient(180deg, rgba(20,22,27,0.9), rgba(10,11,14,0.95));
    box-shadow: 0 20px 80px rgba(0,0,0,0.5);
  }
  .panel h1 { margin: 0 0 0.5rem 0; font-weight: 600; letter-spacing: 1px; }
  .panel p { color: #c2c7d0; line-height: 1.6; }
  .panel .key {
    display: inline-block; border: 1px solid #3a4153; background: #2c3240; color: #cbd3e1;
    padding: 0.15rem 0.4rem; border-radius: 6px; margin: 0 0.2rem; font-size: 12px;
  }
  #whisper {
    position: absolute; top: 8%; width: 100%; text-align: center;
    color: #8ea0b9; opacity: 0; font-size: 16px; transition: opacity 800ms; z-index: 7;
  }
  #centerMsg {
    position: absolute; top: 50%; left: 50%; width: 75vw; transform: translate(-50%, -50%);
    text-align: center; color: #cbd3e1; opacity: 0; pointer-events: none; font-size: 22px;
    transition: opacity 400ms ease; text-shadow: 0 2px 14px rgba(0,0,0,0.8); z-index: 9;
  }
  #pauseOverlay { position: absolute; inset: 0; background: rgba(5,6,8,0.7); display: none; z-index: 8; }
  #jumpscareOverlay { position: absolute; inset: 0; background: red; opacity: 0; z-index: 999; transition: opacity 0.08s ease; }
  #noclipOverlay {
    position: absolute; inset: 0; pointer-events: none; z-index: 11; opacity: 0;
    background: radial-gradient(ellipse at center, rgba(100,100,255,0.2), rgba(0,0,0,0.9) 80%);
    transition: opacity 700ms ease;
  }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="world"></canvas>
  <canvas id="light"></canvas>

  <div id="hud">
    <div>Heart: <span id="heart">â€”</span></div>
    <div class="bar"><div class="fill" id="healthFill" style="width:100%"></div></div>
    <div>Stamina</div>
    <div class="bar"><div class="fill stam" id="stamFill" style="width:100%"></div></div>
    <div>Sanity</div>
    <div class="bar"><div class="fill sanity" id="sanityFill" style="width:100%"></div></div>
  </div>

  <div id="titleOverlay">
    <div class="panel">
      <h1>Hollow Rooms</h1>
      <p>Find the glyph. When you touch it, reality slips. In the Poolrooms, the Blind One only hears, never sees.</p>
      <p><b>Controls:</b> <span class="key">WASD</span>/<span class="key">Arrows</span> move, <span class="key">Shift</span> sprint, <span class="key">Click</span> toggle flashlight (click makes sound), <span class="key">E</span> listen/climb, <span class="key">P/Esc</span> pause.</p>
      <p style="text-align:center;margin-top:0.6rem;"><b>Press SPACE to enter</b></p>
    </div>
  </div>

  <div id="pauseOverlay"></div>
  <div id="whisper"></div>
  <div id="centerMsg"></div>
  <div id="noclipOverlay"></div>
  <div id="jumpscareOverlay"></div>
</div>

<script>
(() => {
  // Utility
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const dist = (ax, ay, bx, by) => Math.hypot(ax - bx, ay - by);
  const rand = (min, max) => Math.random() * (max - min) + min;
  const choice = arr => arr[Math.floor(Math.random() * arr.length)];
  const TAU = Math.PI * 2;

  // Canvas
  const world = document.getElementById('world');
  const light = document.getElementById('light');
  const ctx = world.getContext('2d');
  const ltx = light.getContext('2d');
  function resize() { world.width = innerWidth; world.height = innerHeight; light.width = innerWidth; light.height = innerHeight; }
  window.addEventListener('resize', resize); resize();

  // Audio
  let audio, master, footBus, voiceBus, dangerBus, noiseBus, heartOsc;
  const audioState = { init:false, mute:false, lastBeat:0, lastSoundEventTime:0 };
  function initAudio() {
    if (audioState.init) return;
    audio = new (window.AudioContext || window.webkitAudioContext)();
    master = audio.createGain(); master.gain.value = 0.85; master.connect(audio.destination);
    footBus = audio.createGain(); footBus.gain.value = 0.35; footBus.connect(master);
    voiceBus = audio.createGain(); voiceBus.gain.value = 0.55; voiceBus.connect(master);
    dangerBus = audio.createGain(); dangerBus.gain.value = 0.42; dangerBus.connect(master);
    noiseBus = audio.createGain(); noiseBus.gain.value = 0.22; noiseBus.connect(master);

    heartOsc = audio.createOscillator(); heartOsc.type = 'triangle';
    const heartGain = audio.createGain(); heartGain.gain.value = 0.0;
    heartOsc.connect(heartGain).connect(master); heartOsc.start();

    const bufferSize = 2 * audio.sampleRate;
    const noiseBuffer = audio.createBuffer(1, bufferSize, audio.sampleRate);
    const data = noiseBuffer.getChannelData(0);
    for (let i=0; i<bufferSize; i++) data[i] = Math.random() * 2 - 1;
    const noise = audio.createBufferSource(); noise.buffer = noiseBuffer; noise.loop = true;
    const noiseFilter = audio.createBiquadFilter(); noiseFilter.type = 'lowpass'; noiseFilter.frequency.value = 700;
    noise.connect(noiseFilter).connect(noiseBus); noise.start();

    audioState.heartGain = heartGain; audioState.noise = noiseBus; audioState.init = true;
  }
  function playFootstep(intensity=0.6, pan=0){
    if(!audioState.init || audioState.mute) return;
    const osc = audio.createOscillator(), g = audio.createGain(), p = audio.createStereoPanner();
    p.pan.value = clamp(pan,-1,1); osc.type='square'; osc.frequency.value = rand(90,130);
    osc.connect(g).connect(p).connect(footBus); osc.start();
    g.gain.setTargetAtTime(intensity, audio.currentTime, 0.001);
    g.gain.setTargetAtTime(0.0, audio.currentTime + 0.05, 0.06);
    osc.stop(audio.currentTime + 0.15);
    audioState.lastSoundEventTime = performance.now();
  }
  function whisper(text, dur=3000){
    const w = document.getElementById('whisper'); w.textContent = text; w.style.opacity = '1';
    if(audioState.init && !audioState.mute){
      const osc = audio.createOscillator(), g = audio.createGain(), filt = audio.createBiquadFilter();
      filt.type='bandpass'; filt.frequency.value = rand(200,600); osc.type='sine'; osc.frequency.value = rand(150,300);
      osc.connect(filt).connect(g).connect(voiceBus); osc.start();
      g.gain.setTargetAtTime(0.18,audio.currentTime,0.02);
      g.gain.setTargetAtTime(0.0,audio.currentTime+(dur/1000),0.2);
      osc.stop(audio.currentTime+(dur/1000)+0.3);
    }
    setTimeout(()=>w.style.opacity='0', dur);
  }
  function dangerHum(level=0.5){
    if(!audioState.init || audioState.mute) return;
    const osc = audio.createOscillator(), g = audio.createGain(), filt = audio.createBiquadFilter();
    filt.type='lowpass'; filt.frequency.value=120; osc.type='sawtooth'; osc.frequency.value = rand(40,60);
    osc.connect(filt).connect(g).connect(dangerBus); osc.start();
    g.gain.setTargetAtTime(level, audio.currentTime, 0.4);
    g.gain.setTargetAtTime(0.0, audio.currentTime + 1.8, 0.45);
    osc.stop(audio.currentTime + 2.2);
  }
  function heartbeat(dt, stress){
    if(!audioState.init || audioState.mute) return;
    audioState.lastBeat += dt;
    const bpm = lerp(65, 140, stress);
    const interval = 60 / bpm;
    if(audioState.lastBeat >= interval){
      audioState.lastBeat = 0;
      const t = audio.currentTime, g = audioState.heartGain;
      const base = lerp(40, 80, stress);
      heartOsc.frequency.setTargetAtTime(base, t, 0.01);
      g.gain.setTargetAtTime(0.0, t, 0.01);
      g.gain.setTargetAtTime(0.9, t+0.02, 0.01);
      g.gain.setTargetAtTime(0.0, t+0.09, 0.02);
      g.gain.setTargetAtTime(0.6, t+0.22, 0.01);
      g.gain.setTargetAtTime(0.0, t+0.29, 0.02);
      document.getElementById('heart').textContent = Math.round(bpm);
    }
  }

  // Game/levels
  const CELL = 48;
  let currentLevel = 1; // 1: Hollow Rooms, 2: Poolrooms
  const camera = { x:0, y:0, smooth:0.14 };
  const vision = { base:260, cone:450, jitter:0, flicker:0, darkness:1.0 };

  // Map data
  let MAP_W = 84, MAP_H = 56; // doubled size
  let grid = [];
  let rooms = [];
  function newGrid(w, h, fill=1){ return Array.from({length:h}, () => Array(w).fill(fill)); }

  // Player and entities
  const player = { x:0, y:0, speed:150, stamina:1, health:1, sanity:1, flashlight:true, angle:0, noise:0, lastStep:0, hasLadder:false };
  const exitGlyph = { x:0, y:0, found:false };
  let ladder = { x:0, y:0, found:false };
  let barrierCells = [];
  let climbCell = { gx:0, gy:0 };
  let monsters = []; // {type, ...} includes entityA, entityB, skinWalker, blindOne

  // Input
  const keys = {};
  let paused = false, started = false, lastClickSound = 0;
  window.addEventListener('keydown', e => {
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
    keys[e.code] = true;
    if((e.code==='KeyP' || e.code==='Escape') && started) togglePause();
    if(e.code==='Space' && !started){
      document.getElementById('titleOverlay').classList.add('hidden');
      initAudio();
      started = true;
      whisper("someone stands where you were",2600);
    }
    if(e.code==='KeyE' && started){ tryListen(); tryClimb(); }
  });
  window.addEventListener('keyup', e => keys[e.code] = false);
  window.addEventListener('mousemove', e => {
    const rect = world.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    player.angle = Math.atan2(my - (player.y - camera.y + world.height/2), mx - (player.x - camera.x + world.width/2));
  });
  window.addEventListener('mousedown', () => {
    player.flashlight = !player.flashlight;
    lastClickSound = performance.now();
    audioState.lastSoundEventTime = lastClickSound;
  });

  function togglePause(){ paused = !paused; document.getElementById('pauseOverlay').style.display = paused ? 'block' : 'none'; }

  // Level generation
  function carveRooms(count, wMin, wMax, hMin, hMax){
    rooms = [];
    for(let i=0; i<count; i++){
      const w = Math.floor(rand(wMin, wMax));
      const h = Math.floor(rand(hMin, hMax));
      const x = Math.floor(rand(2, MAP_W - w - 2));
      const y = Math.floor(rand(2, MAP_H - h - 2));
      rooms.push({x, y, w, h});
      for(let yy=0; yy<h; yy++) for(let xx=0; xx<w; xx++) grid[y+yy][x+xx] = 0;
    }
  }
  function connectRooms(strength=0.5){
    rooms.sort((a,b) => a.x - b.x);
    for(let i=0; i<rooms.length-1; i++){
      const a = rooms[i], b = rooms[i+1];
      const ax = Math.floor(a.x + a.w/2), ay = Math.floor(a.y + a.h/2);
      const bx = Math.floor(b.x + b.w/2), by = Math.floor(b.y + b.h/2);
      for(let x=Math.min(ax,bx); x<=Math.max(ax,bx); x++) grid[ay][x] = 0;
      for(let y=Math.min(ay,by); y<=Math.max(ay,by); y++) grid[y][bx] = 0;
      if(Math.random() < strength){ const rx = Math.floor(rand(2, MAP_W-2)); for(let y=0; y<MAP_H; y++) grid[y][rx] = 0; }
    }
  }

  function generateLevelOne(){
    currentLevel = 1;
    MAP_W = 84; MAP_H = 56;
    grid = newGrid(MAP_W, MAP_H, 1);
    carveRooms(28, 5, 14, 5, 12);
    connectRooms(0.5);

    const startRoom = choice(rooms);
    const monsterRoom = choice(rooms.filter(r => r !== startRoom));
    const monsterRoom2 = choice(rooms.filter(r => r !== startRoom && r !== monsterRoom));
    const exitRoom = choice(rooms.filter(r => r !== startRoom && r !== monsterRoom && r !== monsterRoom2));
    const ladderRoom = choice(rooms.filter(r => r !== startRoom && r !== monsterRoom && r !== monsterRoom2 && r !== exitRoom));

    player.x = (startRoom.x + startRoom.w/2) * CELL + CELL/2;
    player.y = (startRoom.y + startRoom.h/2) * CELL + CELL/2;

    exitGlyph.x = (exitRoom.x + Math.floor(exitRoom.w/2)) * CELL + CELL/2;
    exitGlyph.y = (exitRoom.y + Math.floor(exitRoom.h/2)) * CELL + CELL/2;

    ladder = { x:(ladderRoom.x + Math.floor(ladderRoom.w/2)) * CELL + CELL/2,
               y:(ladderRoom.y + Math.floor(ladderRoom.h/2)) * CELL + CELL/2, found:false };
    player.hasLadder = false;
    exitGlyph.found = false;

    const gcx = Math.floor(exitGlyph.x/CELL);
    const gcy = Math.floor(exitGlyph.y/CELL);
    for(let yy=-1; yy<=1; yy++) for(let xx=-1; xx<=1; xx++){ const gy=gcy+yy, gx=gcx+xx; if(gy>=0&&gy<MAP_H&&gx>=0&&gx<MAP_W) grid[gy][gx]=0; }
    barrierCells = [];
    for(let yy=-2; yy<=2; yy++) for(let xx=-2; xx<=2; xx++){
      if(Math.abs(xx)===2 || Math.abs(yy)===2){ const gy=gcy+yy, gx=gcx+xx; if(gy>=0&&gy<MAP_H&&gx>=0&&gx<MAP_W){ grid[gy][gx]=1; barrierCells.push({gx,gy}); } }
    }
    climbCell = { gx: gcx - 2, gy: gcy };

    monsters = [];
    monsters.push({ type:'entityA', x:(monsterRoom.x + monsterRoom.w/2)*CELL + CELL/2, y:(monsterRoom.y + monsterRoom.h/2)*CELL + CELL/2, speed:120, state:'patrol', lastHeard:{x:0,y:0,t:0} });
    monsters.push({ type:'entityB', x:(monsterRoom2.x + monsterRoom2.w/2)*CELL + CELL/2, y:(monsterRoom2.y + monsterRoom2.h/2)*CELL + CELL/2, speed:110, state:'patrol', lastHeard:{x:0,y:0,t:0} });

    const possibleRooms = rooms.filter(r => r !== startRoom && r !== exitRoom && r !== ladderRoom);
    for(let i=0;i<6;i++){
      const r = choice(possibleRooms);
      const sx = (r.x + Math.floor(rand(0, r.w))) * CELL + CELL/2;
      const sy = (r.y + Math.floor(rand(0, r.h))) * CELL + CELL/2;
      monsters.push({ type:'skinWalker', x:sx, y:sy, triggerRadius:3, transformed:false, frozen:false, boltSpeed:520 });
    }
  }

  function generateLevelTwo(){
    currentLevel = 2;
    MAP_W = 96; MAP_H = 64;
    grid = newGrid(MAP_W, MAP_H, 1);

    carveRooms(32, 6, 16, 6, 14);
    connectRooms(0.65);

    const startRoom = choice(rooms);
    const exitRoom = choice(rooms.filter(r => r !== startRoom));
    player.x = (startRoom.x + startRoom.w/2) * CELL + CELL/2;
    player.y = (startRoom.y + startRoom.h/2) * CELL + CELL/2;
    exitGlyph.x = (exitRoom.x + Math.floor(exitRoom.w/2)) * CELL + CELL/2;
    exitGlyph.y = (exitRoom.y + Math.floor(exitRoom.h/2)) * CELL + CELL/2;
    exitGlyph.found = false;

    ladder = { x:0, y:0, found:true };
    barrierCells = [];
    climbCell = { gx:0, gy:0 };

    monsters = [];
    const mRooms = rooms.filter(r => r !== startRoom && r !== exitRoom);
    const rA = choice(mRooms), rB = choice(mRooms.filter(r=>r!==rA));
    monsters.push({ type:'entityA', x:(rA.x + rA.w/2)*CELL + CELL/2, y:(rA.y + rA.h/2)*CELL + CELL/2, speed:120, state:'patrol', lastHeard:{x:0,y:0,t:0} });
    monsters.push({ type:'entityB', x:(rB.x + rB.w/2)*CELL + CELL/2, y:(rB.y + rB.h/2)*CELL + CELL/2, speed:110, state:'patrol', lastHeard:{x:0,y:0,t:0} });

    for(let i=0;i<8;i++){
      const r = choice(mRooms);
      const sx = (r.x + Math.floor(rand(0, r.w))) * CELL + CELL/2;
      const sy = (r.y + Math.floor(rand(0, r.h))) * CELL + CELL/2;
      monsters.push({ type:'skinWalker', x:sx, y:sy, triggerRadius:3, transformed:false, frozen:false, boltSpeed:520 });
    }

    const rBlind = choice(mRooms);
    monsters.push({
      type:'blindOne',
      x:(rBlind.x + rBlind.w/2)*CELL + CELL/2,
      y:(rBlind.y + rBlind.h/2)*CELL + CELL/2,
      speed:115,
      target:{x:(rBlind.x + rBlind.w/2)*CELL + CELL/2, y:(rBlind.y + rBlind.h/2)*CELL + CELL/2},
      lastLock:0,
      sniff:0.0
    });

    vision.base = 300;
    vision.cone = 460;
  }

  generateLevelOne();

  function tryListen(){
    const eA = monsters.find(m=>m.type==='entityA');
    if(eA && dist(player.x,player.y,eA.x,eA.y) < 380) whisper(choice([
      "stop moving","behind the hum there is a door","your steps are loud","the light lies"
    ]), Math.floor(rand(1500,3800)));
    else if(Math.random()<0.5) whisper(choice([
      "nothing is here","pipes breathing","water, and something in it","if you run, it will listen harder"
    ]), Math.floor(rand(1200,2000)));
  }

  function tryClimb(){
    if(currentLevel !== 1) return;
    const climbWorldX = climbCell.gx * CELL + CELL/2;
    const climbWorldY = climbCell.gy * CELL + CELL/2;
    const near = dist(player.x, player.y, climbWorldX, climbWorldY) < 80;
    if(!near) return;
    if(!player.hasLadder){ whisper("something tall blocks your way", 1800); return; }
    if(barrierCells.length){
      for(const c of barrierCells) grid[c.gy][c.gx] = 0;
      barrierCells = [];
      whisper("the barrier gives way",1600);
    }
  }

  let inSkinWalkerCapture = false;
  async function skinWalkerCaptureSequence(){
    if(!audioState.init){ jumpscare(); return; }
    inSkinWalkerCapture = true;
    const prevFoot = footBus.gain.value, prevVoice = voiceBus.gain.value, prevDanger = dangerBus.gain.value, prevMaster = master.gain.value;
    footBus.gain.setTargetAtTime(0.0, audio.currentTime, 0.02);
    voiceBus.gain.setTargetAtTime(0.0, audio.currentTime, 0.02);
    dangerBus.gain.setTargetAtTime(0.0, audio.currentTime, 0.02);
    master.gain.setTargetAtTime(0.6, audio.currentTime, 0.02);
    noiseBus.gain.setTargetAtTime(0.22, audio.currentTime, 0.02);
    await new Promise(res=>setTimeout(res, 5000));
    footBus.gain.setTargetAtTime(prevFoot, audio.currentTime, 0.05);
    voiceBus.gain.setTargetAtTime(prevVoice, audio.currentTime, 0.05);
    dangerBus.gain.setTargetAtTime(prevDanger, audio.currentTime, 0.05);
    master.gain.setTargetAtTime(prevMaster, audio.currentTime, 0.05);
    inSkinWalkerCapture = false;
    jumpscare();
  }

  function jumpscare(){
    const overlay = document.getElementById('jumpscareOverlay');
    overlay.style.opacity = '1';
    if(audioState.init){
      const osc = audio.createOscillator(), g = audio.createGain(), shaper = audio.createWaveShaper();
      const curve = new Float32Array(256);
      for(let i=0;i<curve.length;i++){ const x=i/128-1; curve[i]=Math.tanh(x*8); }
      shaper.curve = curve; shaper.oversample = '4x';
      osc.type='square'; osc.frequency.value = rand(200,520);
      g.gain.value = 1.6;
      osc.connect(shaper).connect(g).connect(master);
      osc.start(); osc.stop(audio.currentTime + 1.6);
    }
    setTimeout(()=>location.reload(), 2000);
  }

  function noclipToLevelTwo(){
    const overlay = document.getElementById('noclipOverlay');
    overlay.style.opacity = '1';
    whisper("you slip between tiles", 1800);
    setTimeout(() => {
      generateLevelTwo();
      overlay.style.opacity = '0';
    }, 900);
  }

  function isSolid(px, py){
    const gx = Math.floor(px / CELL), gy = Math.floor(py / CELL);
    if(gx<0 || gy<0 || gx>=MAP_W || gy>=MAP_H) return true;
    return grid[gy][gx] === 1;
  }
  function moveWithCollide(obj, vx, vy, dt){
    const nx = obj.x + vx * dt, ny = obj.y + vy * dt;
    if(!isSolid(nx, obj.y)) obj.x = nx; else if(!isSolid(nx, obj.y + 14)) obj.x = nx;
    if(!isSolid(obj.x, ny)) obj.y = ny; else if(!isSolid(obj.x + 14, ny)) obj.y = ny;
  }
  function towards(ax, ay, bx, by){ const ang = Math.atan2(by - ay, bx - ax); return { vx:Math.cos(ang), vy:Math.sin(ang), ang }; }

  let last = performance.now();
  function update(dt){
    if(!started || paused) return;

    let mx=0,my=0;
    if(keys['KeyW']||keys['ArrowUp']) my -= 1;
    if(keys['KeyS']||keys['ArrowDown']) my += 1;
    if(keys['KeyA']||keys['ArrowLeft']) mx -= 1;
    if(keys['KeyD']||keys['ArrowRight']) mx += 1;
    const sprint = (keys['ShiftLeft']||keys['ShiftRight']) && player.stamina > 0.05;
    const speed = player.speed * (sprint ? 1.75 : 1.0);
    const mag = Math.hypot(mx,my) || 1;
    const vx = (mx/mag) * speed, vy = (my/mag) * speed;
    moveWithCollide(player, vx, vy, dt);

    const moving = Math.hypot(vx,vy) > 10;
    if(moving){
      player.lastStep += dt;
      const stepInterval = sprint ? 0.32 : 0.55;
      if(player.lastStep >= stepInterval){ player.lastStep = 0; playFootstep(sprint?0.25:0.18, Math.sin(player.angle)*0.6); }
      player.noise = clamp(player.noise + (sprint ? 1.6 : 0.8) * dt, 0, 1.0);
      audioState.lastSoundEventTime = performance.now();
    } else {
      player.noise = clamp(player.noise - 0.8 * dt, 0, 1.0);
    }

    player.stamina = clamp(player.stamina + (sprint ? -0.35 : 0.2) * dt, 0, 1.0);
    const inLight = player.flashlight;
    player.sanity = clamp(player.sanity + (inLight ? 0.04 : -0.06) * dt, 0, 1.0);

    camera.x = lerp(camera.x, player.x, camera.smooth);
    camera.y = lerp(camera.y, player.y, camera.smooth);

    const stress = clamp(0.4*(1 - player.sanity) + 0.6*player.noise + clamp(1 - player.health,0,1), 0, 1);
    vision.jitter = rand(-0.8, 0.8) * stress;
    vision.flicker = Math.abs(Math.sin(performance.now() * 0.002)) * stress * 0.8;
    vision.darkness = lerp(1.0, currentLevel === 1 ? 1.35 : 1.2, stress);
    heartbeat(dt, stress);

    const eA = monsters.find(m=>m.type==='entityA');
    const eB = monsters.find(m=>m.type==='entityB');
    if(player.flashlight){
      if(eA){
        if(Math.random() < player.noise * 0.85 * dt){ eA.lastHeard = { x:player.x, y:player.y, t:performance.now() }; eA.state = 'stalk'; }
        const dA = dist(eA.x,eA.y,player.x,player.y);
        if(dA < 160) eA.state = 'hunt'; else if(dA < 360 && eA.state !== 'hunt') eA.state = 'stalk';
        if(eA.state === 'patrol'){ const roam = choice(rooms); eA.target = { x:(roam.x + rand(0,roam.w))*CELL, y:(roam.y + rand(0,roam.h))*CELL }; }
        if(eA.state === 'stalk' && performance.now() - eA.lastHeard.t > 5000) eA.state = 'patrol';
        const vA = towards(eA.x,eA.y, eA.state==='stalk' ? eA.lastHeard.x : player.x, eA.state==='stalk' ? eA.lastHeard.y : player.y);
        moveWithCollide(eA, vA.vx * eA.speed * lerp(0.7,1.4,stress), vA.vy * eA.speed * lerp(0.7,1.4,stress), dt);
        if(dA < 36){ player.health = clamp(player.health - 0.45 * dt, 0, 1); dangerHum(0.6); if(player.health <= 0){ jumpscare(); return; } }
      }
      if(eB){
        if(Math.random() < player.noise * 0.9 * dt){ eB.lastHeard = { x:player.x, y:player.y, t:performance.now() }; eB.state = 'stalk'; }
        const dB = dist(eB.x,eB.y,player.x,player.y);
        if(dB < 140) eB.state = 'hunt'; else if(dB < 320 && eB.state !== 'hunt') eB.state = 'stalk';
        if(eB.state === 'patrol'){ const roamB = choice(rooms); eB.target = { x:(roamB.x + rand(0,roamB.w))*CELL, y:(roamB.y + rand(0,roamB.h))*CELL }; }
        if(eB.state === 'stalk' && performance.now() - eB.lastHeard.t > 6000) eB.state = 'patrol';
        const vB = towards(eB.x,eB.y, eB.state==='stalk' ? eB.lastHeard.x : player.x, eB.state==='stalk' ? eB.lastHeard.y : player.y);
        moveWithCollide(eB, vB.vx * eB.speed * lerp(0.6,1.3,stress), vB.vy * eB.speed * lerp(0.6,1.3,stress), dt);
        if(dB < 36){ player.health = clamp(player.health - 0.35 * dt, 0, 1); dangerHum(0.5); if(player.health <= 0){ jumpscare(); return; } }
      }
    }

    for(const sw of monsters){
      if(sw.type !== 'skinWalker') continue;
      if(sw.transformed){
        if(!sw.frozen){
          const v = towards(sw.x,sw.y,player.x,player.y);
          sw.x += v.vx * sw.boltSpeed * dt; sw.y += v.vy * sw.boltSpeed * dt;
        }
        if(dist(sw.x,sw.y,player.x,player.y) < 28 && !inSkinWalkerCapture){
          sw.frozen = true;
          skinWalkerCaptureSequence();
        }
      } else {
        if(Math.random() < 0.002){ sw.x += rand(-1,1) * CELL * 0.2; sw.y += rand(-1,1) * CELL * 0.2; }
        const threshold = sw.triggerRadius * CELL;
        if(dist(sw.x,sw.y,player.x,player.y) < threshold){
          sw.transformed = true;
          dangerHum(0.9);
        }
      }
    }

    const blind = monsters.find(m=>m.type==='blindOne');
    if(blind){
      const now = performance.now();
      const heardFootsteps = player.noise > 0;
      const heardClick = (now - lastClickSound) < 1200;
      const heardRecently = (now - audioState.lastSoundEventTime) < 1200;

      if(heardFootsteps || heardClick || heardRecently){
        blind.target = { x: player.x, y: player.y };
        blind.lastLock = now;
        blind.sniff = lerp(blind.sniff, 1.0, 0.15);
      } else {
        if(!blind.target || (now - blind.lastLock) > 3000){
          const roam = choice(rooms);
          blind.target = { x:(roam.x + roam.w/2) * CELL + CELL/2, y:(roam.y + roam.h/2) * CELL + CELL/2 };
          blind.lastLock = now;
          blind.sniff = lerp(blind.sniff, 0.2, 0.05);
        }
      }
      const v = towards(blind.x, blind.y, blind.target.x, blind.target.y);
      const chase = (now - blind.lastLock) < 900;
      const speed = blind.speed * (chase ? 1.8 : 0.9);
      moveWithCollide(blind, v.vx * speed, v.vy * speed, dt);
      if(dist(blind.x, blind.y, player.x, player.y) < 28){
        jumpscare(); return;
      }
    }

    if(currentLevel === 1 && !player.hasLadder && !ladder.found && dist(player.x, player.y, ladder.x, ladder.y) < 30){
      player.hasLadder = true; ladder.found = true;
      if(barrierCells.length){
        for(const c of barrierCells) grid[c.gy][c.gx] = 0;
        barrierCells = [];
        whisper("you hear the barrier shift somewhere far away", 2200);
      }
    }

    if(dist(player.x,player.y,exitGlyph.x,exitGlyph.y) < 40){
      if(currentLevel === 1){
        noclipToLevelTwo();
      } else {
        revealMessage("The water remembers no doors.", 2800);
        setTimeout(()=>location.reload(), 3200);
      }
    }

    if(player.sanity <= 0){ jumpscare(); return; }

    document.getElementById('healthFill').style.width = Math.round(player.health*100)+'%';
    document.getElementById('stamFill').style.width = Math.round(player.stamina*100)+'%';
    document.getElementById('sanityFill').style.width = Math.round(player.sanity*100)+'%';

    if(audioState.init) noiseBus.gain.value = paused ? 0.0 : 0.22;
  }

  function drawWorld(){
    ctx.clearRect(0,0,world.width,world.height);

    const px = player.x - camera.x + world.width/2;
    const py = player.y - camera.y + world.height/2;
    player.xScreen = px; player.yScreen = py;

    if(currentLevel === 1){ ctx.fillStyle = '#0f1217'; }
    else { ctx.fillStyle = '#14222e'; }
    ctx.fillRect(0,0,world.width,world.height);

    for(let y=0; y<MAP_H; y++){
      for(let x=0; x<MAP_W; x++){
        const sx = x*CELL - camera.x + world.width/2;
        const sy = y*CELL - camera.y + world.height/2;
        if(sx+CELL < -20 || sy+CELL < -20 || sx > world.width+20 || sy > world.height+20) continue;
        if(grid[y][x] === 1){
          if(currentLevel === 1){
            ctx.fillStyle = '#0b0d11'; ctx.fillRect(sx, sy, CELL, CELL);
            ctx.fillStyle = '#10131a'; ctx.fillRect(sx+1, sy+1, CELL-2, CELL-2);
          } else {
            ctx.fillStyle = '#0e1a22'; ctx.fillRect(sx, sy, CELL, CELL);
            ctx.fillStyle = 'rgba(255,255,255,0.02)'; ctx.fillRect(sx, sy, CELL, CELL);
          }
        } else {
          if(currentLevel === 1){
            const shade = 15 + Math.floor((x+y)%3)*3;
            ctx.fillStyle = `rgb(${shade},${shade+2},${shade+4})`;
            ctx.fillRect(sx, sy, CELL, CELL);
            ctx.fillStyle = `rgba(20,22,28,0.2)`; ctx.fillRect(sx, sy, CELL, CELL);
          } else {
            const blue = 16 + ((x+y)%3)*4;
            ctx.fillStyle = `rgb(${blue},${blue+14},${blue+22})`;
            ctx.fillRect(sx, sy, CELL, CELL);
            if(Math.random()<0.02){ ctx.fillStyle = 'rgba(180,210,255,0.03)'; ctx.fillRect(sx, sy, CELL, 2); }
          }
        }
      }
    }

    if(currentLevel === 1){
      barrierCells.forEach(({gx, gy}) => {
        const sx = gx*CELL - camera.x + world.width/2;
        const sy = gy*CELL - camera.y + world.height/2;
        ctx.fillStyle = '#090a0e';
        ctx.fillRect(sx, sy, CELL, CELL);
        ctx.fillStyle = '#0f1116';
        ctx.fillRect(sx+1, sy+1, CELL-2, CELL-2);
      });
      const near = dist(player.x, player.y, climbCell.gx*CELL+CELL/2, climbCell.gy*CELL+CELL/2) < 90;
      if(near && barrierCells.length){
        const cx = climbCell.gx*CELL - camera.x + world.width/2;
        const cy = climbCell.gy*CELL - camera.y + world.height/2;
        ctx.save();
        ctx.strokeStyle = 'rgba(255,215,0,0.35)';
        ctx.lineWidth = 3; ctx.strokeRect(cx+4, cy+4, CELL-8, CELL-8);
        ctx.restore();
      }
    }

    const ex = exitGlyph.x - camera.x + world.width/2;
    const ey = exitGlyph.y - camera.y + world.height/2;
    ctx.save(); ctx.translate(ex, ey);
    ctx.rotate(performance.now() * 0.001 % TAU);
    ctx.strokeStyle = '#9c2e2e'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(9, 3); ctx.lineTo(-9, 3); ctx.closePath(); ctx.stroke();
    ctx.restore();

    if(currentLevel === 1 && !ladder.found){
      const lx = ladder.x - camera.x + world.width/2;
      const ly = ladder.y - camera.y + world.height/2;
      ctx.save(); ctx.translate(lx, ly);
      ctx.fillStyle = '#d4af37'; ctx.fillRect(-8,-20,16,40);
      ctx.fillStyle = '#b28f2f'; ctx.fillRect(-8,-6,16,3); ctx.fillRect(-8,6,16,3);
      ctx.restore();
    }

    for(const m of monsters){
      const mx = m.x - camera.x + world.width/2;
      const my = m.y - camera.y + world.height/2;
      ctx.save(); ctx.translate(mx, my);
      if(m.type === 'entityA'){
        ctx.fillStyle = '#0a0b0f'; ctx.beginPath(); ctx.arc(0,0,14,0,TAU); ctx.fill();
        ctx.fillStyle='#10131a'; ctx.fillRect(-5,-20,10,26);
      }
      else if(m.type === 'entityB'){
        ctx.fillStyle = '#0b0c10'; ctx.beginPath(); ctx.ellipse(0,0,12,18,0,0,TAU); ctx.fill();
        ctx.fillStyle='#0f1116'; ctx.fillRect(-4,-18,8,20);
      }
      else if(m.type === 'skinWalker'){
        if(m.transformed){
          ctx.fillStyle = m.frozen ? '#4a0b0b' : '#2b0b0b';
          ctx.beginPath(); ctx.ellipse(0,0,18,26,0,0,TAU); ctx.fill();
          ctx.fillStyle = '#1a0d0d'; ctx.fillRect(-6,-22,12,28);
        } else {
          ctx.fillStyle = '#ffffff';
          ctx.beginPath(); ctx.arc(0,0,10,0,TAU); ctx.fill();
          ctx.globalAlpha = 0.12;
          ctx.fillStyle = '#ffffff';
          ctx.beginPath(); ctx.arc(0,0,18,0,TAU); ctx.fill();
          ctx.globalAlpha = 1.0;
        }
      }
      else if(m.type === 'blindOne'){
        ctx.fillStyle = '#8b0000'; // dark red
        ctx.beginPath(); ctx.ellipse(0,0,12,20,0,0,TAU); ctx.fill();
        ctx.save(); ctx.rotate(-0.2); ctx.fillStyle = '#660000'; ctx.fillRect(-4,-18,8,10); ctx.restore();
      }
      ctx.restore();
    }

    ctx.save(); ctx.translate(px, py); ctx.fillStyle = '#161a22'; ctx.beginPath(); ctx.arc(0,0,10,0,TAU); ctx.fill(); ctx.restore();
  }

  function drawLight(){
    ltx.clearRect(0,0,light.width,light.height);
    ltx.globalCompositeOperation = 'source-over';
    const darkness = currentLevel === 1 ? 0.8 * vision.darkness : 0.75 * vision.darkness;
    const grad = ltx.createRadialGradient(world.width/2, world.height/2, 40, world.width/2, world.height/2, Math.max(world.width, world.height));
    grad.addColorStop(0, `rgba(10,11,14,${0.15 * darkness})`);
    grad.addColorStop(1, `rgba(5,6,8,${currentLevel===1?0.85:0.8 * darkness})`);
    ltx.fillStyle = grad; ltx.fillRect(0,0,light.width,light.height);

    ltx.fillStyle = `rgba(8,9,12,${currentLevel===1?0.25:0.18 * darkness})`;
    ltx.fillRect(0,0,light.width,light.height);

    ltx.globalCompositeOperation = 'destination-out';
    const px = player.xScreen, py = player.yScreen;
    const coneLen = vision.cone + vision.jitter * 16;
    const coneWidth = 0.35 + Math.abs(vision.jitter) * 0.02 + (vision.flicker * 0.08);
    if(player.flashlight){
      ltx.beginPath();
      ltx.moveTo(px, py);
      ltx.lineTo(px + Math.cos(player.angle - coneWidth) * coneLen, py + Math.sin(player.angle - coneWidth) * coneLen);
      ltx.lineTo(px + Math.cos(player.angle + coneWidth) * coneLen, py + Math.sin(player.angle + coneWidth) * coneLen);
      ltx.closePath();
      const coneGrad = ltx.createRadialGradient(px, py, 12, px, py, coneLen);
      coneGrad.addColorStop(0, 'rgba(255,255,255,0.9)');
      coneGrad.addColorStop(0.2, 'rgba(255,255,255,0.6)');
      coneGrad.addColorStop(1, 'rgba(255,255,255,0.0)');
      ltx.fillStyle = coneGrad; ltx.fill();
    }

    ltx.beginPath();
    const halo = vision.base + vision.flicker * 120;
    const haloGrad = ltx.createRadialGradient(px, py, 6, px, py, halo);
    haloGrad.addColorStop(0, 'rgba(255,255,255,0.75)');
    haloGrad.addColorStop(0.1, 'rgba(255,255,255,0.35)');
    haloGrad.addColorStop(1, 'rgba(255,255,255,0.0)');
    ltx.fillStyle = haloGrad; ltx.arc(px, py, halo, 0, TAU); ltx.fill();

    if(currentLevel === 2 && Math.random() < 0.1){
      ltx.globalCompositeOperation = 'source-over';
      ltx.fillStyle = 'rgba(180,210,255,0.02)';
      ltx.fillRect(rand(0, light.width), rand(0, light.height), rand(60, 140), rand(2, 6));
      ltx.globalCompositeOperation = 'destination-out';
    }

    drawStatic();
  }

  function drawStatic(){
    const density = Math.floor((1 - player.sanity) * (currentLevel===1 ? 1400 : 1100));
    if(density <= 0) return;
    ltx.globalCompositeOperation = 'source-over';
    for(let i=0;i<density;i++){
      const x = Math.random() * light.width, y = Math.random() * light.height;
      ltx.fillStyle = `rgba(255,255,255,${Math.random() * 0.22})`;
      ltx.fillRect(x, y, 1, 1);
    }
    ltx.globalCompositeOperation = 'destination-out';
  }

  function revealMessage(text, dur=2000){
    const el = document.getElementById('centerMsg');
    el.textContent = text;
    el.style.opacity = '1';
    setTimeout(()=> el.style.opacity = '0', dur);
  }

  function loop(now){
    const dt = clamp((now - last)/1000, 0, 0.05);
    last = now;
    update(dt);
    drawWorld();
    drawLight();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  let hintTimer = 0;
  setInterval(()=>{
    if(!started || paused) return;
    hintTimer++;
    if(currentLevel===1){
      if(!player.hasLadder && hintTimer % 6 === 0) whisper(choice(["something tall blocks your way","you could go over if you had something","gold rungs in a quiet room"]),2200);
      else if(hintTimer % 7 === 0 && player.sanity > 0.75) whisper("turn off the light and listen",2200);
    } else {
      if(hintTimer % 6 === 0) whisper(choice(["tiles remember footsteps","don't let it hear you","the water is shallow but endless"]),2200);
    }
  }, 3600);

  window.addEventListener('contextmenu', e => e.preventDefault());
})();
</script>
</body>
</html>